<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Generating stubs for a native project, NANOCLR macros, Arguments and return types | nanoFramework Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Generating stubs for a native project, NANOCLR macros, Arguments and return types | nanoFramework Documentation ">
    <meta name="generator" content="docfx 2.58.5.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../../x-cross/toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="generating-stubs-for-a-native-project-nanoclr-macros-arguments-and-return-types">Generating stubs for a native project, NANOCLR macros, Arguments and return types</h1>

<p>When you want to use native code and creating an associated managed code C# library, you should start by reading <a href="https://jsimoesblog.wordpress.com/2018/06/19/interop-in-net-nanoframework/">this article</a>. This article will give you all the steps to create your managed C# project, generate the stubs and have everything glued together.</p>
<p>Once this is done, you'll still have to understand couple of elements related to the <code>NANOCLR</code> macros and the arguments and type conversions.</p>
<h2 id="nanoclr-macros">NANOCLR macros</h2>
<p>Once you generate the stubs, you'll have functions that looks like:</p>
<pre><code class="lang-cpp">HRESULT Library_sys_dev_pwm_native_System_Device_Pwm_PwmChannel::NativeInit___VOID( CLR_RT_StackFrame &amp;stack )
{
    NANOCLR_HEADER();

    NANOCLR_SET_AND_LEAVE(stack.NotImplementedStub());

    NANOCLR_NOCLEANUP();
}
</code></pre>
<p>Every native code that is surfaced with the managed C# code will be generated with pre setup <code>NANOCLR</code> macros. They call all be found in <a href="https://github.com/nanoframework/nf-interpreter/blob/f5d026224116bd671f42d5c482701447b1bf6e70/src/CLR/Include/nanoCLR_Interop.h"><code>src\CLR\Include\nanoCLR_Interop.h</code></a>. With all the elements below, you will be able to understand how to best use them.</p>
<h3 id="nanoclr_header">NANOCLR_HEADER</h3>
<p>The <code>NANOCLR_HEADER</code> is always present at the top of each generated function. It's purpose is ti create the <code>HRESULT hr</code> variable.</p>
<h3 id="nanoclr_cleanup-or-nanoclr_nocleanup-label-or-nolabel">NANOCLR_CLEANUP or NANOCLR_NOCLEANUP, LABEL or NOLABEL</h3>
<p>the <code>CLEANUP</code> family includes 4 declinations and few more elements:</p>
<pre><code class="lang-cpp">#define NANOCLR_LEAVE()  goto nanoCLR_Cleanup // Note: this is a bit simplified version when Debug is not used
#define NANOCLR_RETURN() return hr

#define NANOCLR_CLEANUP()     hr = S_OK; nanoCLR_Cleanup:
#define NANOCLR_CLEANUP_END() NANOCLR_RETURN()
#define NANOCLR_NOCLEANUP()   NANOCLR_CLEANUP(); NANOCLR_CLEANUP_END()
#define NANOCLR_NOCLEANUP_NOLABEL() hr = S_OK; NANOCLR_RETURN()
</code></pre>
<p>So to demystify and understand which one to use, the <code>NANOCLR_NOCLEANUP_NOLABEL();</code> is equivalent to: <code>hr = S_OK; return hr;</code>. So if you don't have to clean anything, that your code is straight forward, that's the general case you can use.</p>
<p>Looking at the <code>NANOCLR_NOCLEANUP</code> one, you'll have something added in the equivalent, a label: <code>hr = S_OK; nanoCLR_Cleanup:; return hr;</code>. As you see the label has been added and looking at few more definition, the <code>NANOCLR_LEAVE</code> macro is <code>goto nanoCLR_Cleanup</code> meaning, anything that needs some check and may leave earlier than a straight forward way will need to have the label version used.</p>
<p>The variation with <code>CLEANUP_END</code> is here to just return hr, it's as well one that can be used when you have nothing to check. While the  <code>NANOCLR_CLEANUP</code> one sets the hr to ok and place the label. It can't be used alone, the <code>NANOCLR_LEAVE</code> will have to be used after.</p>
<h3 id="nanoclr_set_and_leave-nanoclr_check_hresult-and-nanoclr_exit_on_success">NANOCLR_SET_AND_LEAVE, NANOCLR_CHECK_HRESULT and NANOCLR_EXIT_ON_SUCCESS</h3>
<p>Those <code>NANOCLR_CHECK_HRESULT</code> and <code>NANOCLR_EXIT_ON_SUCCESS</code> macros allow you to check if a call to a function or an expression has failed or succeeded and then, as we've seen previously, go to <code>nanoCLR_Cleanup</code>. This is used a lot when you are calling other similar function returning as well an <code>HRESULT</code>.</p>
<pre><code class="lang-cpp">#define NANOCLR_CHECK_HRESULT(expr)   { if(FAILED(hr = (expr))) NANOCLR_LEAVE(); }
#define NANOCLR_EXIT_ON_SUCCESS(expr) { if(SUCCEEDED(hr = (expr))) NANOCLR_LEAVE(); }
#define NANOCLR_SET_AND_LEAVE(expr)   { hr = (expr); NANOCLR_LEAVE(); }
</code></pre>
<p>The <code>NANOCLR_SET_AND_LEAVE</code> function will just set the <code>HRESULT</code> and go to <code>nanoCLR_Cleanup</code>.</p>
<p>You will find a detailed list of typical HRESULT in the <a href="https://github.com/nanoframework/nf-interpreter/blob/f5d026224116bd671f42d5c482701447b1bf6e70/src/CLR/Include/nf_errors_exceptions.h"><code>src\CLR\Include\nf_errors_exceptions.h</code></a> file. FAILED and SUCCEEDED are defined like this:</p>
<pre><code class="lang-cpp">#define SUCCEEDED(Status) ((HRESULT)(Status) &gt;= 0)
#define FAILED(Status) ((HRESULT)(Status)&lt;0)
</code></pre>
<h3 id="nanoclr_msg_set_and_leave-and-nanoclr_msg1_set_and_leave">NANOCLR_MSG_SET_AND_LEAVE and NANOCLR_MSG1_SET_AND_LEAVE</h3>
<p>Those 2 macros are defined like this:</p>
<pre><code class="lang-cpp">#define NANOCLR_MSG_SET_AND_LEAVE(expr, msg)		{ hr = (expr); NANOCLR_LEAVE(); }
#define NANOCLR_MSG1_SET_AND_LEAVE(expr, msg, arg)	{ hr = (expr); NANOCLR_LEAVE(); }
</code></pre>
<p>So they allow you to setup the return element and leave. Those are so far used only in the <code>src\CLR\Core\TypeSystem.cpp</code> file. That said, nothing prevent you to use them as well.</p>
<h2 id="clr_rt_stackframe-stack">CLR_RT_StackFrame &amp;stack</h2>
<p>At every call to one of those native functions, the stack is passed thru a structure called CLR_RT_StackFrame. The definition can be found in <code>src\CLR\Include\nanoCLR_Runtime.h</code>. It would be too long to go thru all the functions and properties. In this description we will focus only on few elements.</p>
<h3 id="if-your-function-is-in-a-static-class">If your function is in a static class</h3>
<p>In, this case, the stack class that you'll get it's is the &quot;static instance&quot; of the C# class. The pointer to the class instance is only available for non static calls. The reason for this is that the execution engine adds a pointer to the class instance to the IL stack, when there is an instance of it.</p>
<h3 id="getting-and-checking-the-stack-in-a-non-static-class">Getting and checking the stack in a non static class</h3>
<p>The pattern to use is the following:</p>
<pre><code class="lang-cpp">CLR_RT_HeapBlock* pThis = stack.This();
FAULT_ON_NULL(pThis);
</code></pre>
<p><code>FAULT_ON_NULL</code> is a macro similar to the onces presented in the previous section which will check of the stack is null or not. In case of null it will go to the <code>nanoCLR_Cleanup</code> label and set the <code>HRESULT</code> to a null fault.</p>
<p>The definition can be found in <code>src\CLR\Include\nanoCLR_Interop.h</code>.</p>
<pre><code class="lang-cpp">#define FAULT_ON_NULL(ptr)     if(!(ptr)) NANOCLR_SET_AND_LEAVE(CLR_E_NULL_REFERENCE)
#define FAULT_ON_NULL_ARG(ptr) if(!(ptr)) NANOCLR_SET_AND_LEAVE(CLR_E_ARGUMENT_NULL)
</code></pre>
<p>You can use those macro for arguments too. We will see this in one of the following section.</p>
<h3 id="getting-any-exposed-field-from-the-stack">Getting any exposed field from the stack</h3>
<p>Once you've checked that the stack is valid, you can get a pointer to any of the class fields. Here is a typical example:</p>
<pre><code class="lang-cpp">int pinNumber = (int)(pThis[Library_sys_dev_pwm_native_System_Device_Pwm_PwmChannel::FIELD___pinNumber].NumericByRef().u4);
</code></pre>
<p>The stack is a <code>CLR_RT_HeapBlock</code>. This type is the core type that allows you get access to a Heap Block, which are the objects that are placed in the IL stack.</p>
<p>The pattern to use is the array one: <code>pthis[the_field_to_get]</code> where you have to make sure the field does exist. To avoid any issue, it is recommended to use the long names like <code>Library_sys_dev_pwm_native_System_Device_Pwm_PwmChannel::FIELD___pinNumber</code>. But if it's in the same class, you don't need the long naming, <code>pThis[FIELD___pinNumber]</code> will just work as well.</p>
<p>Then the <code>NumericByRef()</code> allows you to get a numerical number and <code>u4</code> to convert it as a <code>uint32</code>. For numerics, you have as well <code>NumericByRefConst()</code> allowing to convert as a constant. Then you have <code>u</code> for non signed, 1, 2, 4 and 8 for the number of bytes. <code>i</code> for signed, <code>r4</code> for <code>float</code> and <code>r8</code> for <code>double</code>.</p>
<blockquote>
<p>Pro tip: the generated function definition contains the types and the return type. Example: <code>NativeSetActiveDutyCyclePercentage___VOID__U4</code> is void as return and U4 so uint32 for the first argument. This is done on purpose to help managing the return type and arguments.</p>
</blockquote>
<h2 id="arg0-arg1-argsn">Arg0, Arg1, ArgsN</h2>
<p>Helpers functions available to access the arguments. We will look at this in this section.</p>
<h3 id="static-class">Static class</h3>
<p>In a static class, the <code>stack.Arg0()</code> points the first Heap Block passed on the IL stack. As explained before, do <strong>not</strong> use <code>CLR_RT_HeapBlock* pThis = stack.This();</code> because that won't be a pointer to a class instance (again: this is a call to a static method, therefore there is no instance of the class).</p>
<h3 id="non-static-class">Non static class</h3>
<p>In a non static class, <code>stack.Arg0()</code> is equivalent to <code>stack.This()</code>. The first parameter passed from the C# method can be accessed with Arg1() and the following ones with equivalent calls that have the same index as the parameter.</p>
<h4 id="dereferencing-an-array">Dereferencing an array</h4>
<p>As an example, this time, let's use a function with an array:</p>
<pre><code class="lang-cpp">HRESULT Library_sys_dev_spi_native_System_Device_Spi_SpiDevice::NativeTransfer___VOID__SZARRAY_U2__SZARRAY_U2__BOOLEAN(CLR_RT_StackFrame &amp;stack)
</code></pre>
<p>In this function, the return type is void, it's a non static one, the first and third arguments are <code>SZARRAY</code>, the second and fourth <code>U2</code>.  Still in this example, you will access the first array like this:</p>
<pre><code class="lang-cpp">CLR_RT_HeapBlock_Array *writeBuffer;
uint8_t *writeData = NULL;
writeBuffer = stack.Arg1().DereferenceArray();
if (writeBuffer != NULL)
{
     writeData = (unsigned char *)writeBuffer-&gt;GetFirstElementUInt16();
    // Do something as it's not null
}
</code></pre>
<p>The <code>DereferenceArray()</code> array function will allow you to get an array and to get access to the first element (in this case it's a UInt16 array), you can use <code>GetFirstElementUInt16()</code>. Array have their own heap types: <code>CLR_RT_HeapBlock_Array</code>. As you can guess you have other Element functions for the various system types.</p>
<h4 id="dereferencing-an-object">Dereferencing an object</h4>
<p>Similar to the array, you can dereference an object, a class or a structure. You will then be able to access its fields. Let's use the <code>SpanByte</code> structure as an example.</p>
<pre><code class="lang-cpp">CLR_RT_HeapBlock *writeSpanByte;
CLR_RT_HeapBlock_Array *writeBuffer;
uint8_t *writeData = NULL;
int16_t writeSize = 0;
int16_t writeOffset = 0;
writeSpanByte = stack.Arg1().Dereference();
if (writeSpanByte != NULL)
{
    // get buffer
    writeBuffer = writeSpanByte[SpanByte::FIELD___array].DereferenceArray();
    if (writeBuffer != NULL)
    {
        // Get the write offset, only the elements defined by the span must be written, not the whole
        // array
        writeOffset = writeSpanByte[SpanByte::FIELD___start].NumericByRef().s4;

        // use the span length as write size, only the elements defined by the span must be written
        writeSize = writeSpanByte[SpanByte::FIELD___length].NumericByRef().s4;
        writeData = (unsigned char *)writeBuffer-&gt;GetElement(writeOffset);
    }
}
</code></pre>
<p>SpanByte contains internal fields which are a byte array, a start int32 and length int32 elements. Giving the start and length of the buffer to use. So the pattern is actually to get a reference on the SpanByte, check if not null, get an array reference on the array, check if not nul and you can then have the size of the array. The <code>GetElement()</code> function will point you in the element you need.</p>
<h4 id="argn">ArgN</h4>
<p>You only have 8 defined Arg, when you need to access them further, you can use <code>ArgN(the_number_to_access)</code>.</p>
<blockquote>
<p>Note: it is recommended to move to a class or structure when you start getting too many arguments.</p>
</blockquote>
<h3 id="getting-a-string">Getting a string</h3>
<p>The pattern to get a string from the stack is to use the function <code>RecoverString()</code> if will give you a string.</p>
<pre><code class="lang-cpp">const char* szText = stack.Arg1().RecoverString();
// You can well check if it's a valid non null string like any other heap element:
FAULT_ON_NULL(szText);
</code></pre>
<h3 id="setting-a-result">Setting a result</h3>
<p>You can setup a return result using the family functions <code>SetResult_</code>. System types are directly available like U1 or R4 or any other mentioned before. for example <code>stack.SetResult_U1(42)</code> will place 42 as the return value for a function returning a byte type.</p>
<p><code>SetResult_Object</code> allows you to return any valid object, class or structure.</p>
<p>To return a string, <code>SetResult_String</code> is your best friend. Note that this function returns an <code>HRESULT</code> and should be checked.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/nanoframework/nanoframework.github.io/blob/pages-source/content/architecture/nanoclr-stub-args.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2018 nanoFramework Contributors<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
