{
  "articles/reference-targets/stm32f4-discovery.html": {
    "href": "articles/reference-targets/stm32f4-discovery.html",
    "title": "STMicroelectronics STM32F4DISCOVERY | nanoFramework Documentation",
    "keywords": "STMicroelectronics STM32F4DISCOVERY Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/st-nucleo64-f091rc.html": {
    "href": "articles/reference-targets/st-nucleo64-f091rc.html",
    "title": "STMicroelectronics NUCLEO-F091RC | nanoFramework Documentation",
    "keywords": "STMicroelectronics NUCLEO-F091RC Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/mbn-quail.html": {
    "href": "articles/reference-targets/mbn-quail.html",
    "title": "Mikrobus Net QUAIL | nanoFramework Documentation",
    "keywords": "Mikrobus Net QUAIL Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/esp32-devkitc.html": {
    "href": "articles/reference-targets/esp32-devkitc.html",
    "title": "Espressif ESP32-DevKitC | nanoFramework Documentation",
    "keywords": "Espressif ESP32-DevKitC Product page Firmware images (ready to deploy) Stable Preview"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "nanoFramework APIs | nanoFramework Documentation",
    "keywords": "nanoFramework APIs Our APIs try to follow, as closely as possible, the ones from UWP. The main goal is to potentiate code reuse, existing code samples for Core IoT and even Desktop. This is a work in progress so do check back often for updates. If you find any bugs in documentation we appreciate if you let us know or even better submit a PR with the correction. Happy coding with nanoFramework !"
  },
  "articles/reference-targets-intro.html": {
    "href": "articles/reference-targets-intro.html",
    "title": "Reference target boards | nanoFramework Documentation",
    "keywords": "Reference target boards We provide ready build firmware images for several reference target boards. These can be used for either initial testing and start feeling how cool is to work with nanoFramework or as the base for system designers to develop their own custom boards and firmware. Espressif ESP32 boards ESP32_DEVKITC Mikrobus.Net board MBN_QUAIL Netduino boards NETDUINO3_WIFI STMicroelectronics boards NUCLEO64_F091RC NUCLEO144_F746ZG STM32F4_DISCOVERY STM32F429I_DISCOVERY STM32F769I_DISCOVERY Community target boards There is a GitHub repository that holds target boards provided by community members. Check it here ."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Welcome to nanoFramework knowledge base | nanoFramework Documentation",
    "keywords": "Welcome to nanoFramework knowledge base Getting started guides Getting started guide Reference target boards ESP32_DEVKITC MBN_QUAIL NETDUINO3_WIFI NUCLEO64_F091RC NUCLEO144_F746ZG STM32F4_DISCOVERY STM32F429I_DISCOVERY STM32F769I_DISCOVERY"
  },
  "articles/getting-started-intro.html": {
    "href": "articles/getting-started-intro.html",
    "title": "Getting started with nanoFramework | nanoFramework Documentation",
    "keywords": "Getting started with nanoFramework We have several getting started guides to help you start with nanoFramework . Getting started guide"
  },
  "articles/reference-targets/stm32f769i-discovery.html": {
    "href": "articles/reference-targets/stm32f769i-discovery.html",
    "title": "STMicroelectronics 32F769IDISCOVERY | nanoFramework Documentation",
    "keywords": "STMicroelectronics 32F769IDISCOVERY Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/stm32f429i-discovery.html": {
    "href": "articles/reference-targets/stm32f429i-discovery.html",
    "title": "STMicroelectronics 32F429IDISCOVERY | nanoFramework Documentation",
    "keywords": "STMicroelectronics 32F429IDISCOVERY Product page Features STM32F429ZIT6 mcu 2 Mbytes of internal Flash memory 256 Kbytes of internal RAM 64-Mbit SDRAM (provided as 8 Mbytes of managed heap) 2.4\" QVGA TFT LCD Two user LEDs: LD3 (green), LD4 (red) Two push-buttons (user and reset) USB OTG with micro-AB connector Simple extension header exposing most of the mcu pins On-board ST-LINK/V2 Firmware images (ready to deploy) The ready to use firmware images provided include support for the class libraries and features marked bellow. Gpio Spi I2c Pwm Adc Serial Events SWO Networking Large Heap ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ Stable Preview"
  },
  "articles/reference-targets/st-nucleo144-f746zg.html": {
    "href": "articles/reference-targets/st-nucleo144-f746zg.html",
    "title": "STMicroelectronics NUCLEO144-F746ZG | nanoFramework Documentation",
    "keywords": "STMicroelectronics NUCLEO144-F746ZG Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/netduino3-wifi.html": {
    "href": "articles/reference-targets/netduino3-wifi.html",
    "title": "Wilderness Labs Netduino N3 WiFi | nanoFramework Documentation",
    "keywords": "Wilderness Labs Netduino N3 WiFi Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/getting-started-guides/getting-started-managed.html": {
    "href": "articles/getting-started-guides/getting-started-managed.html",
    "title": "Getting Started Guide | nanoFramework Documentation",
    "keywords": "Getting Started Guide nanoFramework enables the writing of managed code applications for embedded devices. Doesn't matter if you are a seasoned .NET developer or if you've just arrived here and want to give it a try. This getting started guide will walk you through the setup of your development machine to get you coding a nice \"Hello World\" in no time! You can find the video for this guide on our YouTube channel here . The hardware In this guide we'll be using a ST Microelectronics STM32F746 NUCLEO board. This is a rather common and inexpensive board that packs a Cortex M7 with 1MB flash, 320 kB of RAM and includes an ethernet connector. Installing Visual Studio 2017 The first part is to get Visual Studio 2017 and the nanoFramework extension installed. Download Visual Studio 2017. If you already have it installed, you can skip this step. If you don't, please download the free Visual Studio Community 2017 edition. Either way, make sure you've selected the .NET desktop workload. Launch Visual Studio 2017 (we'll just refer to it as VS from now on) and install the nanoFramework extension. You can do this by going into Tools > Extensions and Updates. Make sure you've switched the left-hand tree view to the Online branch and enter nanoFramework in the search box. Now open the Device Explorer window. You can do this by going into View > Other Windows > Device Explorer. Uploading the firmware to the board The second part is to load the nanoFramework image in the board flash. Actually there are two images, one for nanoBooter and another one for nanoCLR. Download the STM32 ST-LINK Utility from ST web site and install it in your development machine. Download a ZIP file with the firmware for the board from our web site here by clicking on the appropriate badge. This will take you to our JFrog Bintray repository that holds the packages with pre-build images for several target boards. After downloading it, unzip the package contents. Connect the STM32F746 NUCLEO board to your PC using an USB cable. In fact, you'll be needing two USB cables with a micro USB connector. One to connect to the ST-Link debugger, that doubles as power supply to the board. And a second one to connect the USB client of the board. Launch the ST-LINK Utility that you've just installed and connect to the STM32F746 NUCLEO board. Perform a \"full chip erase\" to clear the flash. Load the nanoBooter.hex file from the package and hit the \"Program and verify\" button. Make sure you tick the \"Reset after programming\" check box and hit \"Start\". After the upload completes, the MCU is reset and the nanoBooter image runs. You can check the success of the operation watching for a slow blink pattern on the LED. Congratulations, you now have a board running nanoFramework's booter! Next, load the nanoCLR.hex file from the extracted package folder and hit again the \"Program and verify\" button. Make sure you tick the \"Reset after programming\" check box and hit \"Start\". After the upload completes, the MCU is reset and the nanoCLR image will run. This time and if all goes as expected, there will be no LED blinking. You can check if the board is properly running nanoFramework by looking into the Device Explorer window in VS. Coding a 'Hello World' application Now you have everything that you need to start coding your first application. Let's go for a good old 'Hello World' in micro-controller mode, which is blinking a LED, shall we? Go back to VS and click File > New > Project. Make sure you have selected 'Framework 4.6 or above' and choose nanoFramework, on the left hand side tree view. Choose the 'Blank Application' template and a location of your choosing were the project files will be saved. Name your project and hit OK. The program file will be automatically opened for you. We'll code a very simple application that enters an infinite loop and turns on and off an LED. We'll skip the details because that's not the aim of this guide. Let's just grab the code from the nanoFramework samples repo here . Make sure that the correct GPIO pin is being used. That's the line below the comment mentioning the STM32F746 NUCLEO board. Because GPIO is being used we need to pull that class library and a reference to it in our project. The class libraries are distributed through NuGet. To add this class, right click on 'References' in the Solution Explorer and click 'Manage NuGet Packages'. On the search box type 'nanoFramework'. Make sure you have the preview checkbox ticked. Find the Windows.Devices.Gpio package and click \"Install\". After the license confirmation box, the package will be downloaded and a reference to it will be added. You'll notice that you no longer have the unknown references hints in VS. Click \"Build Solution\" from the Build menu. A success message shows in the Build window. We are almost there. Go into the Device Explorer window and click on the nanoFramework device showing there. Make sure the connection is OK by hitting the \"Ping\" button. On success, a message shows on the output window. Let's deploy the application to the board. In order to do that, right click on the Project name and choose \"Deploy\". You'll see the feedback of the several operations that are running on the background in the Output Window. After a successful deployment, your 'Hello World' blinky application will start running and, voilá , the LED starts blinking! Wrapping up Congratulations! That's your first nanoFramework C# application executing right there on the target board. How awesome is that?! And this is it for the getting started guide. You've went through the steps required to install Visual Studio, the nanoFramework extension and the ST-LINK Utility. You've also learned how to upload nanoFramework firmware images into a target board. And last, but not the least: how to code a simple 'Hello World' C# application and deploy it to a target board. Check out other guides and tutorials. You may also want to join our Slack workspace , where you'll find a supportive community to discuss your ideas and help you in case you get stuck on something."
  },
  "articles/faq/working-with-vs-extension.html": {
    "href": "articles/faq/working-with-vs-extension.html",
    "title": "Working with Visual Studio extension | nanoFramework Documentation",
    "keywords": "Working with Visual Studio extension I have a Solution with several class library projects that are referenced in the application project. After a few debug sessions VS complains that it can't access one of them because the file is locked by another process. This occurs because the debugger or de deployment provider have locked that DLL on a previous debug session. To prevent this from happening, you have to open the \"Configuration Manager\" dialog for the Solution and un-check the \"Deploy\" option for all projects except the executable. To remove the lock on that file open a PowerShell console and execute the following command, being NNNN the process number that shows at the very end of the VS message: Stop-Process -id NNNNN ."
  },
  "articles/faq/working-with-stm32-targets.html": {
    "href": "articles/faq/working-with-stm32-targets.html",
    "title": "Working with STM32 targets | nanoFramework Documentation",
    "keywords": "Working with STM32 targets Can I debug the native code on any STM32 board? For that to be possible you need to be able to connect to the JTAG pins on the MCU. Most of the STM32 Discovery and Nucleo boards include a ST-Link hardware that exposes the debug port."
  },
  "articles/faq/working-with-esp32-targets.html": {
    "href": "articles/faq/working-with-esp32-targets.html",
    "title": "Working with ESP32 targets | nanoFramework Documentation",
    "keywords": "Working with ESP32 targets Question 1? Answer 1."
  },
  "articles/faq/coding-in-csharp.html": {
    "href": "articles/faq/coding-in-csharp.html",
    "title": "Coding in C# | nanoFramework Documentation",
    "keywords": "Coding in C# Can I use auto-properties in classes? No, you have to declare the backing fields. I have a Solution that targets both nanoFramework and standard .NET and would like to share/reuse code in both platforms. I know I can't reference assemblies from one into the other. How can I accomplish this? Your best option is to use a shared project to hold the common code. Put there the classes that are to be used in both platforms. You can go all the way into this reusability by using compiler constants, compiler defines and even partial classes. For a small example on this check the ToString sample on our samples repo. It's using this technic to share code between a nanoFramework app and a .NET console app."
  },
  "articles/faq-intro.html": {
    "href": "articles/faq-intro.html",
    "title": "Frequently asked questions | nanoFramework Documentation",
    "keywords": "Frequently asked questions Despite working with nanoFramework being tremendously easy there always moments where one needs a hand or bumps into an award situations. This is a collection of tips, perls of wisdom and answers to frequent situations. Please do contribute with your own! Coding in C# Working with Visual Studio extension Working with ESP32 targets Working with STM32 targets <!-- Coding C/C++ (native firmware) --> <!-- Debugging C/C++ (native firmware) --> <!-- Working with Visual Studio Code --> <!-- Developing Visual Studio extension -->"
  },
  "index.html": {
    "href": "index.html",
    "title": "nanoFramework documentation | nanoFramework Documentation",
    "keywords": "nanoFramework documentation Explore our knowledge base, API documentation, samples, guides and tutorials. Getting started guides Reference target boards Keep in mind that this a work in progress 😉"
  }
}