{
  "articles/reference-targets-intro.html": {
    "href": "articles/reference-targets-intro.html",
    "title": "Reference target boards | nanoFramework Documentation",
    "keywords": "Reference target boards We provide ready build firmware images for several reference target boards. These can be used for either initial testing and start feeling how cool is to work with nanoFramework or as the base for system designers to develop their own custom boards and firmware. Espressif ESP32 boards ESP32_DEVKITC Mikrobus.Net board MBN_QUAIL Netduino boards NETDUINO3_WIFI STMicroelectronics boards NUCLEO64_F091RC NUCLEO144_F746ZG STM32F4_DISCOVERY STM32F429I_DISCOVERY STM32F769I_DISCOVERY Community target boards There is a GitHub repository that holds target boards provided by community members. Check it here ."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Welcome to nanoFramework knowledge base | nanoFramework Documentation",
    "keywords": "Welcome to nanoFramework knowledge base Getting started guides Managed Getting Started Guide Native Build nanoFramework - STM32 Build nanoFramework - ESP32 Reference target boards ESP32_DEVKITC MBN_QUAIL NETDUINO3_WIFI NUCLEO64_F091RC NUCLEO144_F746ZG STM32F4_DISCOVERY STM32F429I_DISCOVERY STM32F769I_DISCOVERY"
  },
  "articles/getting-started-intro.html": {
    "href": "articles/getting-started-intro.html",
    "title": "Getting started with nanoFramework | nanoFramework Documentation",
    "keywords": "Getting started with nanoFramework We have several getting started guides to help you start with nanoFramework . Managed Getting started guide Native Build nanoFramework - STM32 Build nanoFramework - ESP32"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "nanoFramework APIs | nanoFramework Documentation",
    "keywords": "nanoFramework APIs Our APIs try to follow, as closely as possible, the ones from UWP. The main goal is to potentiate code reuse, existing code samples for Core IoT and even Desktop. This is a work in progress so do check back often for updates. If you find any bugs in documentation we appreciate if you let us know or even better submit a PR with the correction. Happy coding with nanoFramework !"
  },
  "articles/reference-targets/stm32f4-discovery.html": {
    "href": "articles/reference-targets/stm32f4-discovery.html",
    "title": "STMicroelectronics STM32F4DISCOVERY | nanoFramework Documentation",
    "keywords": "STMicroelectronics STM32F4DISCOVERY Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/st-nucleo64-f091rc.html": {
    "href": "articles/reference-targets/st-nucleo64-f091rc.html",
    "title": "STMicroelectronics NUCLEO-F091RC | nanoFramework Documentation",
    "keywords": "STMicroelectronics NUCLEO-F091RC Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/st-nucleo144-f746zg.html": {
    "href": "articles/reference-targets/st-nucleo144-f746zg.html",
    "title": "STMicroelectronics NUCLEO144-F746ZG | nanoFramework Documentation",
    "keywords": "STMicroelectronics NUCLEO144-F746ZG Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/netduino3-wifi.html": {
    "href": "articles/reference-targets/netduino3-wifi.html",
    "title": "Wilderness Labs Netduino N3 WiFi | nanoFramework Documentation",
    "keywords": "Wilderness Labs Netduino N3 WiFi Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/getting-started-guides/build-stm32.html": {
    "href": "articles/getting-started-guides/build-stm32.html",
    "title": "How to Build, Flash and Debug the STM32 nanoBooter and nanoCLR on Windows using Visual Studio Code | nanoFramework Documentation",
    "keywords": "How to Build, Flash and Debug the STM32 nanoBooter and nanoCLR on Windows using Visual Studio Code Table of contents Prerequisites Setting up the build environment for STM32 nanoFramework Github Repo Set up Visual Studio Code Build nanoBooter and nanoCLR Flash the STM32 target Next Steps About this document This document describes how to build the required images for nanoFramework for STM32 targets. The build is based on CMake tool to ease the development in all major platforms. Prerequisites You'll need: Visual Studio Code Visual Studio Code Extensions C/C++ - C/C++ IntelliSense, debugging, and code browsing (by Microsoft) CMake - language support for Visual Studio Code (by twxs) CMake Tools - Extended CMake support in Visual Studio Code (by vector-of-bool) CMake (Minimum required version is 3.11) A build system for CMake to generate the build files to. If you have Visual Studio (full version) you can use the included NMake. Ninja . This is lightweight build system, designed for speed and it works on Windows and Linux machines. See here how to setup Ninja to build nanoFramework . This guide will use Ninja. GNU ARM Embedded Toolchain OpenOCD (any working distribution will work, some suggestions follow)\\ Freddie Chopin OpenOCD OpenOCD – Open On-Chip Debugger GNU ARM Eclipse OpenOCD ChibiOS - Technically you do not need to download this, the build scripts will do this automatically if you do not specify a path to ChibiOS in the CMake-variants.json (more info here ). Setting up the build environment for STM32 To simplify, this guide we will put all our tools and source in easily accessible folders and not at the default install paths (you do not have to do the same): Create a directory structure such as the following: C:\\nanoFramework_Tools C:\\nanoFramework Download and install Visual Studio Code. Download and install CMake to C:\\nanoFramework_Tools\\CMake Download Ninja and place the executable in C:\\nanoFramework_Tools\\Ninja Download and install the GNU ARM Embedded Toolchain to C:\\nanoFramework_Tools\\GNU_ARM_Toolchain Download and extract ChibiOS to C:\\nanoframework_tools\\ChibiOS-stable_18.2.x Finally, clone nf-interpreter into C:\\nanoFramework\\nf-interpreter . See next section for more info. nanoFramework GitHub repo If you intend to change the nanoBooter or nanoCLR for the STM32 target and create Pull Requests then you will need to fork the nanoFramework/nf-interpreter to your own GitHub repo and clone the forked GitHub repo to your Windows system using an Git client such as the GitHub Desktop application . See the Contributing to nanoFramework guide for specific instructions when contributing. If you don't intend to make changes to the nanoBooter and nanoCLR, you can clone nanoFramework/nf-interpreter directly from here. Set up Visual Studio Code Install the extensions: C/C++ CMake CMake Tools Set up the CMake-variants.json in root directory of your local nanoFramework/nf-interpreter clone. There is a template file called cmake-variants.TEMPLATE.json that can be renamed and configured accordingly. More info available on the Tweaking cmake-variants.TEMPLATE.json documentation page. For any of the Reference target boards you can find pre-populated template files here . Here is an example CMake-variants.json for the STM32F429I-DISCOVERY: { \"buildType\": { \"default\": \"MinSizeRel\", \"choices\": { \"debug\": { \"short\": \"Debug\", \"long\": \"Emit debug information without performing optimizations\", \"buildType\": \"Debug\" }, \"release\": { \"short\": \"Release\", \"long\": \"Enable optimizations, omit debug info\", \"buildType\": \"Release\" }, \"minsize\": { \"short\": \"MinSizeRel\", \"long\": \"Optimize for smallest binary size\", \"buildType\": \"MinSizeRel\" }, \"reldeb\": { \"short\": \"RelWithDebInfo\", \"long\": \"Perform optimizations AND include debugging information\", \"buildType\": \"RelWithDebInfo\" } } }, \"linkage\": { \"default\": \"\", \"choices\": { \"ST_STM32F429I_DISCOVERY\": { \"short\": \"ST_STM32F429I_DISCOVERY\", \"settings\": { \"BUILD_VERSION\" : \"0.9.99.999\", \"TOOLCHAIN_PREFIX\" : \"C:/nanoFramework_Tools/GNU_ARM_Toolchain\", \"TARGET_SERIES\" : \"STM32F4xx\", \"USE_RNG\" : \"ON\", \"CHIBIOS_SOURCE\" : \"C:/nanoFramework_Tools/ChibiOS-stable_18.2.x\", \"CHIBIOS_BOARD\" : \"ST_STM32F429I_DISCOVERY\", \"SWO_OUTPUT\" : \"ON\", \"NF_FEATURE_DEBUGGER\" : \"ON\", \"NF_FEATURE_RTC\" : \"ON\", \"API_Windows.Devices.Adc\" : \"ON\", \"API_Windows.Devices.Gpio\" : \"ON\", \"API_Windows.Devices.Spi\" : \"ON\", \"API_Windows.Devices.I2c\" : \"ON\" } } } } } In the .vscode create a file named settings.json and paste the following { \"cmake.generator\": \"Ninja\", \"cmake.configureSettings\": { \"CMAKE_MAKE_PROGRAM\":\"C:/nanoFramework_Tools/ninja/ninja.exe\" }, \"cmake.cmakePath\": \"C:/nanoFramework_Tools/CMake/bin/cmake.exe\" } Save all files and exit VS Code. Reopen VS Code. It should load the workspace automatically. In the status bar at the bottom left, click on the No Kit Selected and select [Unspecified] . In the status bar at the bottom left, click on the CMake:MinSizeRel ST_STM32F429I_DISCOVERY: Ready and select MinSizeRel . Wait for it to finish Configuring the project (progress bar shown in right bottom corner). Build nanoBooter and nanoCLR In the status bar click Build . Wait for the build to finish with Build finished with exit code 0 output message. In the C:\\nanoFramework\\nf-interpreter\\build folder will be the required binary files: nanoBooter.bin nanoBooter.elf nanoBooter.hex nanoCLR.bin nanoCLR.elf nanoCLR.hex Flash the STM32 target Download the STM32 ST-LINK Utility from ST web site and install it in your development machine. Connect the Target board to your PC using an USB cable. Open STM32 ST-Link Utility. And click on Target > Connect . Next erase the entire chip by clicking on Target > Erase Chip . Open nanoBooter.hex ( Open > Open File... ) and program and verify ( Target > Program & Verify... ). Make sure you tick the Reset after programming check box and hit Start . After the upload completes, the MCU is reset and the nanoBooter image runs. You can check the success of the operation watching for a slow blink pattern on the LED. Congratulations, you now have a board running nanoFramework's booter! Open nanoCLR.hex ( Open > Open File... ) and program and verify ( Target > Program & Verify... ). Make sure you tick the Reset after programming check box and hit Start . After the upload completes, the MCU is reset and the nanoCLR image will run. This time and if all goes as expected, there will be no LED blinking. Next Steps See Getting Started for instructions on creating and running a 'Hello World' managed application on your nanoFramework board."
  },
  "articles/getting-started-guides/build-esp32.html": {
    "href": "articles/getting-started-guides/build-esp32.html",
    "title": "How to Build, Flash and Debug the ESP32 nanoCLR on Windows using Visual Code | nanoFramework Documentation",
    "keywords": "How to Build, Flash and Debug the ESP32 nanoCLR on Windows using Visual Code Table of contents Prerequisites Setting up the build environment for ESP32 Set up Visual Studio Code Build the nanoCLR Flash nanoCLR to ESP32 Start with a Hello World C# application Debug the nanoCLR Notes on JTAG Debugging on ESP32 About this document This document describes how to build the required images for nanoFramework for ESP32. The build is based on CMake tool to ease the development in all major platforms. Prerequisites You'll need these installed before your start. Visual Studio Code . Additional extensions and setup steps follow below. Set up Visual Code Python 3.6.5 Required for uploading the nanoCLR to the ESP32. CMake Download the latest stable version and install it (Minimum required version is 3.11). A build system for CMake to generate the build files to. If you have Visual Studio (full version) you can use the included NMake. In Visual Studio Code, use Ninja. Ninja can be installed for you or you can do it manually. CP210x USB to UART Bridge Driver for the USB to UART Bridge integrated into the standard ESP32 DevKitC. If Windows does not install the driver automatically, then you can download and install manually. If your ESP32 uses a different serila driver, install that and ignore this driver. With the ESP32 DevKetC plugged in, use Windows Device Manager to determine the COM port as this is needed to complete the setup. The following may be installed manually , or use the Power Shell script .\\install-esp32-tools.ps1 Ninja . This is lightweight build system, designed for speed and it works on Windows and Linux machines. See here how to setup Ninja to build nanoFramework . OpenOCD For on chip debugging of the nanoCLR nanoFramework GitHub repo If you intend to change the nanoCLR for ESP32 and create Pull Requests then you will need to fork the nanoFramework/nf-interpreter to your own GitHub repo and clone the forked GitHub repo to your Windows system using an Git client such as the GitHub Desktop application . You should use the develop branch for mainstream development or the develop-network branch to work with the networking features which is currently a work in progress. A guide to making contributions is provided here Setting up the build environment for ESP32 After cloning the repo, you need to setup the build environemnt. You can use the power shell script or follow the step-by-step instrunctions. Automated Install of the build environment for ESP32 The following power shell script is not signed. Run Power Shell as an Administrator and run set-executionpolicy remotesigned to enable execution of the non-signed script. On Windows, one may use the .\\install-esp32-tools.ps1 Power Shell script located in the repository root folder to download the ESP32 IDF Source, toolchain, prebuilt libraries, OpenOCD (for JTAG debugging) and Ninja Zips. You may need to use Run as Administrator for power shell to permit installing modules to unzip the downloaded archives. The script will download the zips into the repository folder and extract them into subfolders of the main ESP32 tool folder: C:\\Esp32_Tools Open Power Shell in the root folder of the repository and run the script specifying the COM port the ESP32 flash programming utility will use (The COM port is easily changed later. If it is not specified, manually edit tasks.json and change instances of <COMPORT> to the required port before flashing the ESP32 nanoCLR firmware.) Example Power Shell command line: .\\install-esp32-tools.ps1 -COMPORT COM19 You can force the environemnt variables to be updated by adding -Force to the command line. The script will create the following subfolders (see manual install below and appveyor.yml) C:\\Esp32_Tools\\1.22.0-80 C:\\Esp32_Tools\\esp-idf-v3.1 C:\\Esp32_Tools\\libs-v3.1 C:\\Esp32_Tools\\ninja C:\\Esp32_Tools\\openocd-esp32 The following Environment Variables will be created for the current Windows User. ESP32_TOOLS_PATH = C:\\ESP32_TOOLS ESP32_TOOLCHAIN_PATH = C:\\ESP32_TOOLS\\1.22.0-80\\xtensa-esp32-elf ESP32_LIBS_PATH = C:\\ESP32_TOOLS\\libs-v3.1 IDF_PATH = C:\\ESP32_TOOLS\\esp-idf-v3.1 NINJA_PATH = C:\\ESP32_TOOLS\\ninja The following ESP32 settings files will be created and the place-holder values set to the respective default install paths. .\\cmake-variants.json as a copy of .\\cmake-variants.TEMPLATE-ESP32.json .\\.vscode\\cmake-kits.json as a copy of .\\.vscode\\cmake-kits.TEMPLATE-ESP32.json .\\.vscode\\tasks.json as a copy of .\\vscode\\tasks.TEMPLATE-ESP32.json with install paths and COM port set .\\.vscode\\launch.json as a copy of .\\vscode\\launch.TEMPLATE-ESP32.json with install paths set Manual Install of the build environment for ESP32 These steps are not required if you used the Automated Install script. To save time on building the nanoCLR and to avoid having to create a CMakeLists.txt project for the ESP32 IDF files, the ESP32 IDF libraries are prebuilt using the Esp32 Msys32 environment then used for linking in the CMake build of nanoCLR. This has already been done and the libraries can be just be downloaded. Create a directory such as the following: C:\\Esp32_Tools C:\\Esp32_Tools\\libs-v3.1 Download the pre-built libs zip from here and extract it into C:\\Esp32_Tools\\libs-v3.1 . Download the v3.1 IDF source zip file from here and extract it into C:\\Esp32_Tools so you get C:\\ESP32_Tools\\esp-idf-v3.1\\components etc. Download the Esp32 toolchain from here and extract it into C:\\Esp32_Tools\\1.22.0.80 so you get C:\\Esp32_Tools\\1.22.0.80\\xtensa-esp32-elf . For on chip debugging of the nanoCLR, download OpenOCD from here and extract OpenOCD into C:\\Esp32_Tools so you get C:\\Esp32_Tools\\openocd-esp32 . Download the light weight build system Ninja for CMake to generate the build files from here . This is lightweight build system, designed for speed and it works on Windows and Linux machines. See here how to setup Ninja to build nanoFramework . If you have Visual Studio (full version) you can use the included NMake. Define the environment variables to match the install locations. Default locations are: ESP32_TOOLS_PATH = C:\\ESP32_TOOLS ESP32_TOOLCHAIN_PATH = C:\\ESP32_TOOLS\\1.22.0-80\\xtensa-esp32-elf ESP32_LIBS_PATH = C:\\ESP32_TOOLS\\libs-v3.1 IDF_PATH = C:\\ESP32_TOOLS\\esp-idf-v3.1 NINJA_PATH = C:\\ESP32_TOOLS\\ninja Add Ninja to the PATH (i.e. C:\\ESP32_TOOLS\\ninja ) Set up CMake Download the latest stable version from here and install it. Set up Ninja Extract the exe into C:\\Esp32_Tools\\ninja and add the C:\\Esp32_Tools\\ninja directory to your path variable. Note that .\\install-esp32-tools.ps1 will do this for you. Set up Python Install Python 3.6.5 and then install the serial driver for python from the command line: python -m pip install pyserial Note that .\\install-esp32-tools.ps1 will install pyserial for you if you installed Python prior to running the script. (It is Ok to run python -m pip install pyserial multiple times.) Set up Visual Studio Code Install the extensions: \"C/C++\" extension by Microsoft. \"CMake\" language support for Visual Studio Code by twxs. \"CMake tools\" Extended CMake support in Visual Studio code by vector-of-bool Set up the CMake-variants.json in root directory of your local nanoFramework/nf-interpreter clone. See cmake-variants.TEMPLATE.json for the generalised template. Be aware of the forward slashes in the paths. The TOOLCHAIN_PREFIX should be set to the directory where the xtensa-esp32-elf is the subdirectory. There is a template file called cmake-variants.TEMPLATE-ESP32.json that can be copied to CMake-variants.json and used if you followed the paths in this guide. If different install paths were used, then edit the file accordingly. { \"buildType\": { \"default\": \"debug\", \"choices\": { \"debug\": { \"short\": \"Debug\", \"long\": \"Emit debug information without performing optimizations\", \"buildType\": \"Debug\" }, \"release\": { \"short\": \"Release\", \"long\": \"Enable optimizations, omit debug info\", \"buildType\": \"Release\" }, \"minsize\": { \"short\": \"MinSizeRel\", \"long\": \"Optimize for smallest binary size\", \"buildType\": \"MinSizeRel\" }, \"reldeb\": { \"short\": \"RelWithDebInfo\", \"long\": \"Perform optimizations AND include debugging information\", \"buildType\": \"RelWithDebInfo\" } } }, \"linkage\": { \"default\": \"\", \"choices\": { \"Esp32_nanoCLR\": { \"short\": \"NanoCLR\", \"settings\": { \"BUILD_VERSION\" : \"0.9.99.999\", \"TOOLCHAIN_PREFIX\" : \"<absolute-path-to-the-toolchain-prefix-folder-mind-the-forward-slashes>\", \"ESP32_IDF_PATH\" : \"<absolute-path-to-the-IDF-folder-mind-the-forward-slashes>\", \"ESP32_LIBS_PATH\" : \"<absolute-path-to-the-bootloader-folder-mind-the-forward-slashes>\", \"TARGET_SERIES\" : \"ESP32\", \"USE_FPU\" : \"TRUE\", \"RTOS\" : \"FREERTOS\", \"SWO_OUTPUT\" : \"OFF\", \"NF_BUILD_RTM\" : \"OFF\", \"NF_WP_TRACE_ERRORS\" : \"OFF\", \"NF_WP_TRACE_HEADERS\" : \"OFF\", \"NF_WP_TRACE_STATE\" : \"OFF\", \"NF_WP_TRACE_NODATA\" : \"OFF\", \"NF_WP_TRACE_ALL\" : \"OFF\", \"NF_WP_IMPLEMENTS_CRC32\" : \"OFF\", \"NF_FEATURE_DEBUGGER\" : \"ON\", \"NF_FEATURE_RTC\" : \"ON\", \"NF_FEATURE_USE_APPDOMAINS\" : \"OFF\", \"NF_FEATURE_USE_FILESYSTEM\" : \"OFF\", \"NF_SECURITY_OPENSSL\" : \"ON\", \"API_System.Net\" : \"ON\", \"API_Windows.Networking.Sockets\" : \"OFF\", \"API_Windows.Devices.Wifi\": \"ON\", \"API_Windows.Devices.Adc\" : \"ON\", \"API_Windows.Devices.Gpio\" : \"ON\", \"API_Windows.Devices.I2c\" : \"ON\", \"API_Windows.Devices.Pwm\" : \"ON\", \"API_Windows.Devices.SerialCommunication\" : \"ON\", \"API_Windows.Devices.Spi\" : \"ON\", \"API_Hardware.Esp32\" : \"ON\" } } } } } Create a ./.vscode/cmake-kits.json from /.vscode/cmake-kits.TEMPLATE-ESP32.json . The default template file is ok, and may be copied to ./.vscode/cmake-kits.json [ { \"name\": \"ESP32 Tools\", \"toolchainFile\": \"CMake/toolchain.FreeRtos.ESP32.GCC.cmake\" } ] Create a ./.vscode/tasks.json from /.vscode/tasks.TEMPLATE-ESP32.json . For flashing the nanoCLR into the ESP32 or to erase the flash of the ESP32 you will need a tasks.json file. You can manually copy the template ( tasks.TEMPLATE-ESP32.json ) and then adjust the COM port and the varios paths with place holders ( !!mind the forward slashes!! ) to your needs. The Power Shell script .\\install-esp32-tools.ps1 will adjust the file for you if you used it. Use the paramter '-C COM6' to select COM6 for flashing the ESP32 DevKitC. { \"version\": \"2.0.0\", \"tasks\": [ { \"taskName\": \"Flash nanoCLR <COMPORT>\", \"type\": \"shell\", \"command\": \"python <absolute-path-to-the-IDF-folder-mind-the-forward-slashes>/components/esptool_py/esptool/esptool.py --chip esp32 --port \\\"<COMPORT>\\\" --baud 460800 --before \\\"default_reset\\\" --after \\\"hard_reset\\\" write_flash -z --flash_mode \\\"dio\\\" --flash_freq \\\"40m\\\" --flash_size detect 0x1000 <absolute-path-to-the-bootloader-folder-mind-the-forward-slashes>/bootloader.bin 0x10000 <path-to-nanoFramework-build-directory-mind-the-forward-slashes>/nanoCLR.bin 0x8000 <path-to-nanoFramework-build-directory-mind-the-forward-slashes>/partitions_4mb.bin\", \"presentation\": { \"reveal\": \"always\", \"panel\": \"shared\" }, \"problemMatcher\": [] }, { \"taskName\": \"Erase flash <COMPORT>\", \"type\": \"shell\", \"command\": \"python <absolute-path-to-the-IDF-folder-mind-the-forward-slashes>/components/esptool_py/esptool/esptool.py --chip esp32 --port \\\"<COMPORT>\\\" --baud 460800 --before \\\"default_reset\\\" --after \\\"hard_reset\\\" erase_flash\", \"presentation\": { \"reveal\": \"always\", \"panel\": \"shared\" }, \"problemMatcher\": [] } ] } Build nanoCLR Launch Visual Studio and from the File menu, seletc Open Folder and browse to the repo folder. VSCode will prompt asking \"Would you like to configure this project?\". Ignore the prompt as you need to select the build varient first. To enter a command into Visual Studio Code use the key combination Ctrl+Shift+P. Click on CMake in the Status bar or enter the command CMake: Set build varient and set it to the Debug + NanoCLR build type. If it also asks for a kit select ESP32 Tools Wait for CMake to process the files and build the CMake cache. This can take a while the first time. Press F7, or click on Build in the Status bar or enter the command CMake: Build If you get no error you will have in the build directory the files nanoCLR.bin and partitions_4mb.bin . The third file that gets flashed into the ESP32 is the bootloader.bin which will be located here C:/ESP32_Tools/libs-v3.1/bootloader.bin if the automated install script is used. Flash nanoCLR into ESP32 Connect your development board to the computer port that you've setup in tasks.json . Bring your board into download mode by holding down the GPIO0 pin to GND or holding down the respective button during power up. In Visual Studio Code enter the command Tasks: Run task and if you flash the board for the first time Erase flash and then Flash nanoCLR Start with a 'Hello World' C# application Watch the video tutorial here and follow the step that should be done in Visual Studio 2017 Community Editon. Skip the steps that describing uploading the nanoCLR into the STM32 Nucleo board. Debugging nanoCLR If you want to debug the nanoCLR on the ESP32 chip you can use the Olimex ARM-USB-OCD-H JTAG debugging adapter. The following setup is specific for the Olimex ARM-USB-OCD-H but you can use other configuration files to get it working with other JTAG adapters. Create a ./.vscode/launch.json from /.vscode/launch.TEMPLATE-ESP32.json . Edit the file and adjust the absolute path <absolute-path-to-the-build-folder-mind-the-forward-slashes> to the build folder ( !!mind the forward slashes!! ) to your needs. The Power Shell script .\\install-esp32-tools.ps1 will adjust the file for you. The following example assumes the OpenOCD tool was installed in the default location. Adjust the path as required if you used a custom install path to OpenOCD. { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"ESP32 nanoCLR - OLimex OCD-H\", \"type\": \"cppdbg\", \"request\": \"launch\", \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:/ESP32_Tools/1.22.0-80/xtensa-esp32-elf/bin/xtensa-esp32-elf-gdb.exe\", \"stopAtEntry\":true, \"program\": \"<absolute-path-to-the-build-folder-mind-the-forward-slashes>/targets/FreeRTOS/ESP32_DevKitC/nanoCLR.elf\", \"setupCommands\": [ {\"text\": \"set logging on\"}, {\"text\": \"target extended-remote localhost:3333\"}, {\"text\": \"file <absolute-path-to-the-build-folder-mind-the-forward-slashes>/nanoCLR.elf\"}, {\"text\": \"monitor reset halt\"}, {\"text\": \"thb app_main\"}, {\"text\": \"x $a1=0\"} ], \"launchCompleteCommand\": \"exec-run\", \"debugServerPath\": \"C:/Esp32_Tools/openocd-esp32/bin/openocd.exe\", \"debugServerArgs\": \"-s \\\"C:/Esp32_Tools/openocd-esp32/share/openocd/scripts/\\\" -f interface/ftdi/olimex-arm-usb-ocd-h.cfg -f target/esp32.cfg -c \\\"adapter_khz 3000\\\" \" , \"serverStarted\": \"Info : .*Tensilica.*0x1.\", \"filterStderr\": true, \"externalConsole\": true, \"cwd\": \"${cwd}\", \"logging\": { \"trace\": true, \"traceResponse\": true, \"engineLogging\": true, \"programOutput\": true, \"exceptions\": true, \"moduleLoad\": true } } ] } You can now debug nanoCLR on the ESP32 by pressing F5 in Visual Studio Code. Notes on JTAG debugging on ESP32 The JTAG connections on ESP32 DEVKITC are: TDI -> GPIO12 TCK -> GPIO13 TMS -> GPIO14 TDO -> GPIO15 TRST -> EN / RST (Reset) GND -> GND See Gojimmypi for description of JTAG connections: https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html If flashing nanoCLR via a COM port (default), then be aware that you need to disconnect the JTAG to avoid it preventing the bootloader from running, and therefore being unable to reprogram the ESP23. e.g. if you see the following pattern repeating, unplug the USB-OCD-H, and then the programming will proceed. esptool.py v2.1 Connecting........_____....._____... The Esp32 only has 2 hardware breakpoints. As code is dynamically loaded unless the method has an IRAM_ATTR attribute any breakpoints set up at the start will cause an error when you try to debug (Unable to set breakpoint). When launched the debugger will normally stop at the main task. Its not possible to set a break point on code that is not yet loaded so either step down to a point that it is loaded or temporarily set the method with the IRAM_ATTR attribute. For more information on JTAG debugging see Espressif documentaion ."
  },
  "articles/faq/working-with-vs-extension.html": {
    "href": "articles/faq/working-with-vs-extension.html",
    "title": "Working with Visual Studio extension | nanoFramework Documentation",
    "keywords": "Working with Visual Studio extension I have a Solution with several class library projects that are referenced in the application project. After a few debug sessions VS complains that it can't access one of them because the file is locked by another process. This occurs because the debugger or de deployment provider have locked that DLL on a previous debug session. To prevent this from happening, you have to open the \"Configuration Manager\" dialog for the Solution and un-check the \"Deploy\" option for all projects except the executable. To remove the lock on that file open a PowerShell console and execute the following command, being NNNN the process number that shows at the very end of the VS message: Stop-Process -id NNNNN . When I build a project/solutions it fails with an error NFMDP: Error 0x81010009 . What is this? This happens when you are using a C# feature that is not currently supported by nanoFramework. The most common cases are generics or a complicated Linq expression. There is currently no way to point you exactly where the issue is. The best suggestion is to build often so you can spot this as early as possible. It can also help if you comment the code that you've added recently and start uncomment as you run the build. This way you'll have a general guidance on where the root cause could be."
  },
  "articles/faq/working-with-esp32-targets.html": {
    "href": "articles/faq/working-with-esp32-targets.html",
    "title": "Working with ESP32 targets | nanoFramework Documentation",
    "keywords": "Working with ESP32 targets Question 1? Answer 1."
  },
  "articles/faq-intro.html": {
    "href": "articles/faq-intro.html",
    "title": "Frequently asked questions | nanoFramework Documentation",
    "keywords": "Frequently asked questions Despite working with nanoFramework being tremendously easy there always moments where one needs a hand or bumps into an award situations. This is a collection of tips, perls of wisdom and answers to frequent situations. Please do contribute with your own! Coding in C# Working with Visual Studio extension Working with ESP32 targets Working with STM32 targets <!-- Coding C/C++ (native firmware) --> <!-- Debugging C/C++ (native firmware) --> <!-- Working with Visual Studio Code --> <!-- Developing Visual Studio extension -->"
  },
  "articles/faq/coding-in-csharp.html": {
    "href": "articles/faq/coding-in-csharp.html",
    "title": "Coding in C# | nanoFramework Documentation",
    "keywords": "Coding in C# Can I use auto-properties in classes? No, you have to declare the backing fields. I have a Solution that targets both nanoFramework and standard .NET and would like to share/reuse code in both platforms. I know I can't reference assemblies from one into the other. How can I accomplish this? Your best option is to use a shared project to hold the common code. Put there the classes that are to be used in both platforms. You can go all the way into this reusability by using compiler constants, compiler defines and even partial classes. For a small example on this check the ToString sample on our samples repo. It's using this technic to share code between a nanoFramework app and a .NET console app."
  },
  "articles/reference-targets/stm32f769i-discovery.html": {
    "href": "articles/reference-targets/stm32f769i-discovery.html",
    "title": "STMicroelectronics 32F769IDISCOVERY | nanoFramework Documentation",
    "keywords": "STMicroelectronics 32F769IDISCOVERY Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/stm32f429i-discovery.html": {
    "href": "articles/reference-targets/stm32f429i-discovery.html",
    "title": "STMicroelectronics 32F429IDISCOVERY | nanoFramework Documentation",
    "keywords": "STMicroelectronics 32F429IDISCOVERY Product page Features STM32F429ZIT6 mcu 2 Mbytes of internal Flash memory 256 Kbytes of internal RAM 64-Mbit SDRAM (provided as 8 Mbytes of managed heap) 2.4\" QVGA TFT LCD Two user LEDs: LD3 (green), LD4 (red) Two push-buttons (user and reset) USB OTG with micro-AB connector Simple extension header exposing most of the mcu pins On-board ST-LINK/V2 Firmware images (ready to deploy) The ready to use firmware images provided include support for the class libraries and features marked bellow. Gpio Spi I2c Pwm Adc Serial Events SWO Networking Large Heap ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ Stable Preview"
  },
  "articles/reference-targets/mbn-quail.html": {
    "href": "articles/reference-targets/mbn-quail.html",
    "title": "Mikrobus Net QUAIL | nanoFramework Documentation",
    "keywords": "Mikrobus Net QUAIL Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/reference-targets/esp32-devkitc.html": {
    "href": "articles/reference-targets/esp32-devkitc.html",
    "title": "Espressif ESP32-DevKitC | nanoFramework Documentation",
    "keywords": "Espressif ESP32-DevKitC Product page Firmware images (ready to deploy) Stable Preview"
  },
  "articles/getting-started-guides/getting-started-managed.html": {
    "href": "articles/getting-started-guides/getting-started-managed.html",
    "title": "Getting Started Guide | nanoFramework Documentation",
    "keywords": "Getting Started Guide nanoFramework enables the writing of managed code applications for embedded devices. Doesn't matter if you are a seasoned .NET developer or if you've just arrived here and want to give it a try. This getting started guide will walk you through the setup of your development machine to get you coding a nice \"Hello World\" in no time! You can find the video for this guide on our YouTube channel here . The hardware In this guide we'll be using a ST Microelectronics STM32F746 NUCLEO board. This is a rather common and inexpensive board that packs a Cortex M7 with 1MB flash, 320 kB of RAM and includes an ethernet connector. Installing Visual Studio 2017 The first part is to get Visual Studio 2017 and the nanoFramework extension installed. Download Visual Studio 2017. If you already have it installed, you can skip this step. If you don't, please download the free Visual Studio Community 2017 edition. Either way, make sure you've selected the .NET desktop workload. Launch Visual Studio 2017 (we'll just refer to it as VS from now on) and install the nanoFramework extension. You can do this by going into Tools > Extensions and Updates. Make sure you've switched the left-hand tree view to the Online branch and enter nanoFramework in the search box. Now open the Device Explorer window. You can do this by going into View > Other Windows > Device Explorer. Uploading the firmware to the board The second part is to load the nanoFramework image in the board flash. Actually there are two images, one for nanoBooter and another one for nanoCLR. Download the STM32 ST-LINK Utility from ST web site and install it in your development machine. Download a ZIP file with the firmware for the board from our web site here by clicking on the appropriate badge. This will take you to our JFrog Bintray repository that holds the packages with pre-build images for several target boards. After downloading it, unzip the package contents. Connect the STM32F746 NUCLEO board to your PC using an USB cable. In fact, you'll be needing two USB cables with a micro USB connector. One to connect to the ST-Link debugger, that doubles as power supply to the board. And a second one to connect the USB client of the board. Launch the ST-LINK Utility that you've just installed and connect to the STM32F746 NUCLEO board. Perform a \"full chip erase\" to clear the flash. Load the nanoBooter.hex file from the package and hit the \"Program and verify\" button. Make sure you tick the \"Reset after programming\" check box and hit \"Start\". After the upload completes, the MCU is reset and the nanoBooter image runs. You can check the success of the operation watching for a slow blink pattern on the LED. Congratulations, you now have a board running nanoFramework's booter! Next, load the nanoCLR.hex file from the extracted package folder and hit again the \"Program and verify\" button. Make sure you tick the \"Reset after programming\" check box and hit \"Start\". After the upload completes, the MCU is reset and the nanoCLR image will run. This time and if all goes as expected, there will be no LED blinking. You can check if the board is properly running nanoFramework by looking into the Device Explorer window in VS. Coding a 'Hello World' application Now you have everything that you need to start coding your first application. Let's go for a good old 'Hello World' in micro-controller mode, which is blinking a LED, shall we? Go back to VS and click File > New > Project. Make sure you have selected 'Framework 4.6 or above' and choose nanoFramework, on the left hand side tree view. Choose the 'Blank Application' template and a location of your choosing were the project files will be saved. Name your project and hit OK. The program file will be automatically opened for you. We'll code a very simple application that enters an infinite loop and turns on and off an LED. We'll skip the details because that's not the aim of this guide. Let's just grab the code from the nanoFramework samples repo here . Make sure that the correct GPIO pin is being used. That's the line below the comment mentioning the STM32F746 NUCLEO board. Because GPIO is being used we need to pull that class library and a reference to it in our project. The class libraries are distributed through NuGet. To add this class, right click on 'References' in the Solution Explorer and click 'Manage NuGet Packages'. On the search box type 'nanoFramework'. Make sure you have the preview checkbox ticked. Find the Windows.Devices.Gpio package and click \"Install\". After the license confirmation box, the package will be downloaded and a reference to it will be added. You'll notice that you no longer have the unknown references hints in VS. Click \"Build Solution\" from the Build menu. A success message shows in the Build window. We are almost there. Go into the Device Explorer window and click on the nanoFramework device showing there. Make sure the connection is OK by hitting the \"Ping\" button. On success, a message shows on the output window. Let's deploy the application to the board. In order to do that, right click on the Project name and choose \"Deploy\". You'll see the feedback of the several operations that are running on the background in the Output Window. After a successful deployment, your 'Hello World' blinky application will start running and, voilá , the LED starts blinking! Wrapping up Congratulations! That's your first nanoFramework C# application executing right there on the target board. How awesome is that?! And this is it for the getting started guide. You've went through the steps required to install Visual Studio, the nanoFramework extension and the ST-LINK Utility. You've also learned how to upload nanoFramework firmware images into a target board. And last, but not the least: how to code a simple 'Hello World' C# application and deploy it to a target board. Check out other guides and tutorials. You may also want to join our Slack workspace , where you'll find a supportive community to discuss your ideas and help you in case you get stuck on something."
  },
  "articles/faq/working-with-stm32-targets.html": {
    "href": "articles/faq/working-with-stm32-targets.html",
    "title": "Working with STM32 targets | nanoFramework Documentation",
    "keywords": "Working with STM32 targets Can I debug the native code on any STM32 board? For that to be possible you need to be able to connect to the JTAG pins on the MCU. Most of the STM32 Discovery and Nucleo boards include a ST-Link hardware that exposes the debug port."
  },
  "index.html": {
    "href": "index.html",
    "title": "nanoFramework documentation | nanoFramework Documentation",
    "keywords": "nanoFramework documentation Explore our knowledge base, API documentation, samples, guides and tutorials. Getting started guides Reference target boards Keep in mind that this a work in progress 😉"
  },
  "api/Windows.Storage.Streams.IDataReader.html": {
    "href": "api/Windows.Storage.Streams.IDataReader.html",
    "title": "Interface IDataReader | nanoFramework Documentation",
    "keywords": "Interface IDataReader Provides read access to an input stream. Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public interface IDataReader Properties | Improve this Doc View Source ByteOrder Gets or sets the byte order of the data in the input stream. Declaration ByteOrder ByteOrder { get; set; } Property Value Type Description ByteOrder One of the enumeration values. | Improve this Doc View Source InputStreamOptions Gets or sets the read options for the input stream. Declaration InputStreamOptions InputStreamOptions { get; set; } Property Value Type Description InputStreamOptions One of the enumeration values. | Improve this Doc View Source UnconsumedBufferLength Gets the size of the buffer that has not been read. Declaration uint UnconsumedBufferLength { get; } Property Value Type Description System.UInt32 The size of the buffer that has not been read, in bytes. | Improve this Doc View Source UnicodeEncoding Gets or sets the Unicode character encoding for the input stream. Declaration UnicodeEncoding UnicodeEncoding { get; set; } Property Value Type Description UnicodeEncoding One of the enumeration values. Methods | Improve this Doc View Source DetachBuffer() Detaches a buffer that was previously attached to the reader. Declaration IBuffer DetachBuffer() Returns Type Description IBuffer The detached buffer. | Improve this Doc View Source DetachStream() Detaches a stream that was previously attached to the reader. Declaration IInputStream DetachStream() Returns Type Description IInputStream The detached stream. | Improve this Doc View Source Load(UInt32) Loads data from the input stream. Declaration uint Load(UInt32 count) Parameters Type Name Description UInt32 count The count of bytes to load into the intermediate buffer. Returns Type Description System.UInt32 The asynchronous operation. | Improve this Doc View Source ReadBoolean() Reads a Boolean value from the input stream. Declaration bool ReadBoolean() Returns Type Description System.Boolean The value. | Improve this Doc View Source ReadBuffer(UInt32) Reads a buffer from the input stream. Declaration IBuffer ReadBuffer(UInt32 length) Parameters Type Name Description UInt32 length The length of the buffer, in bytes. Returns Type Description IBuffer The buffer. | Improve this Doc View Source ReadByte() Reads a byte value from the input stream. Declaration byte ReadByte() Returns Type Description System.Byte The value. | Improve this Doc View Source ReadBytes(Byte[]) Reads an array of byte values from the input stream. Declaration void ReadBytes(Byte[] value) Parameters Type Name Description Byte [] value The array of values. | Improve this Doc View Source ReadDateTime() Reads a date and time value from the input stream. Declaration DateTime ReadDateTime() Returns Type Description DateTime The value. | Improve this Doc View Source ReadDouble() Reads a floating-point value from the input stream. Declaration double ReadDouble() Returns Type Description System.Double The value. | Improve this Doc View Source ReadGuid() Reads a GUID value from the input stream. Declaration Guid ReadGuid() Returns Type Description Guid The value. | Improve this Doc View Source ReadInt16() Reads a 16-bit integer value from the input stream. Declaration short ReadInt16() Returns Type Description System.Int16 The value. | Improve this Doc View Source ReadInt32() Reads a 32-bit integer value from the input stream. Declaration int ReadInt32() Returns Type Description System.Int32 The value. | Improve this Doc View Source ReadInt64() Reads a 64-bit integer value from the input stream. Declaration long ReadInt64() Returns Type Description System.Int64 The value. | Improve this Doc View Source ReadSingle() Reads a floating-point value from the input stream. Declaration float ReadSingle() Returns Type Description System.Single The value. | Improve this Doc View Source ReadString(UInt32) Reads a string value from the input stream. Declaration string ReadString(UInt32 codeUnitCount) Parameters Type Name Description UInt32 codeUnitCount The length of the string. Returns Type Description System.String The value. | Improve this Doc View Source ReadTimeSpan() Reads a time interval from the input stream. Declaration TimeSpan ReadTimeSpan() Returns Type Description TimeSpan The value. | Improve this Doc View Source ReadUInt16() Reads a 16-bit unsigned integer from the input stream. Declaration ushort ReadUInt16() Returns Type Description System.UInt16 The value. | Improve this Doc View Source ReadUInt32() Reads a 32-bit unsigned integer from the input stream. Declaration uint ReadUInt32() Returns Type Description System.UInt32 The value. | Improve this Doc View Source ReadUInt64() Reads a 64-bit unsigned integer from the input stream. Declaration ulong ReadUInt64() Returns Type Description System.UInt64 The value."
  },
  "api/Windows.Storage.Streams.Buffer.html": {
    "href": "api/Windows.Storage.Streams.Buffer.html",
    "title": "Class Buffer | nanoFramework Documentation",
    "keywords": "Class Buffer Provides a default implementation of the IBuffer interface and its related interfaces. Inheritance System.Object Buffer Implements IBuffer Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public sealed class Buffer : object, IBuffer Constructors | Improve this Doc View Source Buffer(UInt32) Initializes a new instance of the Buffer class with the specified capacity. Declaration public Buffer(UInt32 capacity) Parameters Type Name Description UInt32 capacity The maximum number of bytes that the buffer can hold. Properties | Improve this Doc View Source Capacity Gets the maximum number of bytes that the buffer can hold. Declaration public uint Capacity { get; } Property Value Type Description System.UInt32 The maximum number of bytes that the buffer can hold. | Improve this Doc View Source Length Gets the number of bytes currently in use in the buffer. Declaration public uint Length { get; set; } Property Value Type Description System.UInt32 The number of bytes currently in use in the buffer, which is less than or equal to the capacity of the buffer. Implements IBuffer"
  },
  "api/Windows.Storage.Streams.IDataWriter.html": {
    "href": "api/Windows.Storage.Streams.IDataWriter.html",
    "title": "Interface IDataWriter | nanoFramework Documentation",
    "keywords": "Interface IDataWriter Provides write access to an output stream. Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public interface IDataWriter Properties | Improve this Doc View Source ByteOrder Gets or sets the byte order of the data in the output stream. Declaration ByteOrder ByteOrder { get; set; } Property Value Type Description ByteOrder One of the enumeration values. | Improve this Doc View Source UnicodeEncoding Gets or sets the Unicode character encoding for the output stream. Declaration UnicodeEncoding UnicodeEncoding { get; set; } Property Value Type Description UnicodeEncoding One of the enumeration values. | Improve this Doc View Source UnstoredBufferLength Gets the size of the buffer that has not been used. Declaration uint UnstoredBufferLength { get; } Property Value Type Description System.UInt32 The available buffer length, in bytes. Methods | Improve this Doc View Source DetachBuffer() Detaches a buffer that was previously attached to the writer. Declaration IBuffer DetachBuffer() Returns Type Description IBuffer The detached buffer. | Improve this Doc View Source DetachStream() Detaches a stream that was previously attached to the writer. Declaration IOutputStream DetachStream() Returns Type Description IOutputStream The detached stream. | Improve this Doc View Source Flush() Flushes data. Declaration bool Flush() Returns Type Description System.Boolean The stream flush operation. Remarks The Flush method ensures that the data has reached the target storage medium that the stream represents. For example, to improve application responsiveness and throughput, a file stream might respond to a write operation by copying the buffer into another temporary storage medium and returning immediately, while the target device begins writing the data concurrently. The Flush method doesn't complete until all data specified in previous write calls has reached the target storage medium. If the data can't be written, or an error occurred during a write operation, the method returns false. The Flush method may produce latencies and does not always guarantee durable and coherent storage of data.It's generally recommended to avoid this method if possible. | Improve this Doc View Source MeasureString(String) Gets the size of a string. Declaration uint MeasureString(String value) Parameters Type Name Description String value The string. Returns Type Description System.UInt32 The size of the string, in bytes. | Improve this Doc View Source Store() Commits data in the buffer to a backing store. Declaration uint Store() Returns Type Description System.UInt32 The store data operation. | Improve this Doc View Source WriteBoolean(Boolean) Writes a Boolean value to the output stream. Declaration void WriteBoolean(Boolean value) Parameters Type Name Description Boolean value The value to write. | Improve this Doc View Source WriteBuffer(IBuffer) Writes a number of bytes from a buffer to the output stream. Declaration void WriteBuffer(IBuffer buffer) Parameters Type Name Description IBuffer buffer The value to write. | Improve this Doc View Source WriteBuffer(IBuffer, UInt32, UInt32) Writes a range of bytes from a buffer to the output stream. Declaration void WriteBuffer(IBuffer buffer, UInt32 start, UInt32 count) Parameters Type Name Description IBuffer buffer The buffer. UInt32 start The starting byte to be written. UInt32 count The number of bytes to write. | Improve this Doc View Source WriteByte(Byte) Writes a byte value to the output stream. Declaration void WriteByte(Byte value) Parameters Type Name Description Byte value The value to write. | Improve this Doc View Source WriteBytes(Byte[]) Writes an array of byte values to the output stream. Declaration void WriteBytes(Byte[] value) Parameters Type Name Description Byte [] value The value to write. | Improve this Doc View Source WriteDateTime(DateTime) Writes a date and time value to the output stream. Declaration void WriteDateTime(DateTime value) Parameters Type Name Description DateTime value The value to write. | Improve this Doc View Source WriteDouble(Double) Writes a floating-point value to the output stream. Declaration void WriteDouble(Double value) Parameters Type Name Description Double value The value to write. | Improve this Doc View Source WriteGuid(Guid) Writes a GUID value to the output stream. Declaration void WriteGuid(Guid value) Parameters Type Name Description Guid value The value to write. | Improve this Doc View Source WriteInt16(Int16) Writes a 16-bit integer value to the output stream. Declaration void WriteInt16(Int16 value) Parameters Type Name Description Int16 value The value to write. | Improve this Doc View Source WriteInt32(Int32) Writes a 32-bit integer value to the output stream. Declaration void WriteInt32(Int32 value) Parameters Type Name Description Int32 value The value to write. | Improve this Doc View Source WriteInt64(Int64) Writes a 64-bit integer value to the output stream. Declaration void WriteInt64(Int64 value) Parameters Type Name Description Int64 value The value to write. | Improve this Doc View Source WriteSingle(Single) Write a floating-point value to the output stream. Declaration void WriteSingle(Single value) Parameters Type Name Description Single value The value to write. | Improve this Doc View Source WriteString(String) Writes a string value to the output stream. Declaration uint WriteString(String value) Parameters Type Name Description String value The value to write. Returns Type Description System.UInt32 The length of the string. | Improve this Doc View Source WriteTimeSpan(TimeSpan) Writes a time interval value to the output stream. Declaration void WriteTimeSpan(TimeSpan value) Parameters Type Name Description TimeSpan value The value to write. | Improve this Doc View Source WriteUInt16(UInt16) Writes a 16-bit unsigned integer value to the output stream. Declaration void WriteUInt16(UInt16 value) Parameters Type Name Description UInt16 value The value to write. | Improve this Doc View Source WriteUInt32(UInt32) Writes a 32-bit unsigned integer value to the output stream. Declaration void WriteUInt32(UInt32 value) Parameters Type Name Description UInt32 value The value to write. | Improve this Doc View Source WriteUInt64(UInt64) Writes a 64-bit unsigned integer value to the output stream. Declaration void WriteUInt64(UInt64 value) Parameters Type Name Description UInt64 value The value to write."
  },
  "api/Windows.Storage.Streams.IBuffer.html": {
    "href": "api/Windows.Storage.Streams.IBuffer.html",
    "title": "Interface IBuffer | nanoFramework Documentation",
    "keywords": "Interface IBuffer Represents a referenced array of bytes used by byte stream read and write interfaces. Buffer is the class implementation of this interface. Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public interface IBuffer Properties | Improve this Doc View Source Capacity Gets the maximum number of bytes that the buffer can hold. Declaration uint Capacity { get; } Property Value Type Description System.UInt32 The maximum number of bytes that the buffer can hold. | Improve this Doc View Source Length Gets the number of bytes currently in use in the buffer. Declaration uint Length { get; set; } Property Value Type Description System.UInt32 The number of bytes currently in use in the buffer which is less than or equal to the capacity of the buffer."
  },
  "api/Windows.Storage.Streams.DataWriter.html": {
    "href": "api/Windows.Storage.Streams.DataWriter.html",
    "title": "Class DataWriter | nanoFramework Documentation",
    "keywords": "Class DataWriter Writes data to an output stream. Inheritance System.Object DataWriter Implements IDataWriter Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public sealed class DataWriter : IDisposable, IDataWriter Constructors | Improve this Doc View Source DataWriter() Creates and initializes a new instance of the data writer. Declaration public DataWriter() | Improve this Doc View Source DataWriter(IOutputStream) Creates and initializes a new instance of the data writer to an output stream. Declaration public DataWriter(IOutputStream outputStream) Parameters Type Name Description IOutputStream outputStream The new output stream instance. Properties | Improve this Doc View Source ByteOrder Gets or sets the byte order of the data in the output stream. Declaration public ByteOrder ByteOrder { get; set; } Property Value Type Description ByteOrder One of the enumeration values. | Improve this Doc View Source UnicodeEncoding Gets or sets the Unicode character encoding for the output stream. Declaration public UnicodeEncoding UnicodeEncoding { get; set; } Property Value Type Description UnicodeEncoding One of the enumeration values. | Improve this Doc View Source UnstoredBufferLength Gets the size of the buffer that has not been used. Declaration public uint UnstoredBufferLength { get; } Property Value Type Description System.UInt32 The available buffer length, in bytes. Methods | Improve this Doc View Source Close() Closes the current stream and releases system resources. Declaration public void Close() Remarks DataWriter takes ownership of the stream that is passed to its constructor. Calling this method also calls on the associated stream. After calling this method, calls to most other DataWriter methods will fail. If you do not want the associated stream to be closed when the reader closes, call DataWriter.DetachStream before calling this method. | Improve this Doc View Source DetachBuffer() Detaches a buffer that was previously attached to the writer. Declaration public IBuffer DetachBuffer() Returns Type Description IBuffer The detached buffer. | Improve this Doc View Source DetachStream() Detaches a stream that was previously attached to the writer. Declaration public IOutputStream DetachStream() Returns Type Description IOutputStream The detached stream. | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Improve this Doc View Source Flush() Flushes data. Declaration public bool Flush() Returns Type Description System.Boolean The stream flush operation. Remarks The Flush method ensures that the data has reached the target storage medium that the stream represents. For example, to improve application responsiveness and throughput, a file stream might respond to a write operation by copying the buffer into another temporary storage medium and returning immediately, while the target device begins writing the data concurrently. The Flush method doesn't complete until all data specified in previous write calls has reached the target storage medium. If the data can't be written, or an error occurred during a write operation, the method returns false. The Flush method may produce latencies and does not always guarantee durable and coherent storage of data.It's generally recommended to avoid this method if possible. | Improve this Doc View Source MeasureString(String) Gets the size of a string. Declaration public uint MeasureString(String value) Parameters Type Name Description String value The string. Returns Type Description System.UInt32 The size of the string, in bytes. | Improve this Doc View Source Store() Commits data in the buffer to a backing store. Declaration public uint Store() Returns Type Description System.UInt32 The store data operation. | Improve this Doc View Source WriteBoolean(Boolean) Writes a Boolean value to the output stream. Declaration public void WriteBoolean(Boolean value) Parameters Type Name Description Boolean value The value to write. | Improve this Doc View Source WriteBuffer(IBuffer) Writes a number of bytes from a buffer to the output stream. Declaration public void WriteBuffer(IBuffer buffer) Parameters Type Name Description IBuffer buffer The value to write. | Improve this Doc View Source WriteBuffer(IBuffer, UInt32, UInt32) Writes a range of bytes from a buffer to the output stream. Declaration public void WriteBuffer(IBuffer buffer, UInt32 start, UInt32 count) Parameters Type Name Description IBuffer buffer The buffer. UInt32 start The starting byte to be written. UInt32 count The number of bytes to write. | Improve this Doc View Source WriteByte(Byte) Writes a byte value to the output stream. Declaration public void WriteByte(Byte value) Parameters Type Name Description Byte value The value to write. | Improve this Doc View Source WriteBytes(Byte[]) Writes an array of byte values to the output stream. Declaration public void WriteBytes(Byte[] value) Parameters Type Name Description Byte [] value The value to write. | Improve this Doc View Source WriteDateTime(DateTime) Writes a date and time value to the output stream. Declaration public void WriteDateTime(DateTime value) Parameters Type Name Description DateTime value The value to write. | Improve this Doc View Source WriteDouble(Double) Writes a floating-point value to the output stream. Declaration public void WriteDouble(Double value) Parameters Type Name Description Double value The value to write. | Improve this Doc View Source WriteGuid(Guid) Writes a GUID value to the output stream. Declaration public void WriteGuid(Guid value) Parameters Type Name Description Guid value The value to write. | Improve this Doc View Source WriteInt16(Int16) Writes a 16-bit integer value to the output stream. Declaration public void WriteInt16(Int16 value) Parameters Type Name Description Int16 value The value to write. | Improve this Doc View Source WriteInt32(Int32) Writes a 32-bit integer value to the output stream. Declaration public void WriteInt32(Int32 value) Parameters Type Name Description Int32 value The value to write. | Improve this Doc View Source WriteInt64(Int64) Writes a 64-bit integer value to the output stream. Declaration public void WriteInt64(Int64 value) Parameters Type Name Description Int64 value The value to write. | Improve this Doc View Source WriteSingle(Single) Write a floating-point value to the output stream. Declaration public void WriteSingle(Single value) Parameters Type Name Description Single value The value to write. | Improve this Doc View Source WriteString(String) Writes a string value to the output stream. Declaration public uint WriteString(String value) Parameters Type Name Description String value The value to write. Returns Type Description System.UInt32 The length of the string. | Improve this Doc View Source WriteTimeSpan(TimeSpan) Writes a time interval value to the output stream. Declaration public void WriteTimeSpan(TimeSpan value) Parameters Type Name Description TimeSpan value The value to write. | Improve this Doc View Source WriteUInt16(UInt16) Writes a 16-bit unsigned integer value to the output stream. Declaration public void WriteUInt16(UInt16 value) Parameters Type Name Description UInt16 value The value to write. | Improve this Doc View Source WriteUInt32(UInt32) Writes a 32-bit unsigned integer value to the output stream. Declaration public void WriteUInt32(UInt32 value) Parameters Type Name Description UInt32 value The value to write. | Improve this Doc View Source WriteUInt64(UInt64) Writes a 64-bit unsigned integer value to the output stream. Declaration public void WriteUInt64(UInt64 value) Parameters Type Name Description UInt64 value The value to write. Implements IDataWriter"
  },
  "api/Windows.Storage.Streams.UnicodeEncoding.html": {
    "href": "api/Windows.Storage.Streams.UnicodeEncoding.html",
    "title": "Enum UnicodeEncoding | nanoFramework Documentation",
    "keywords": "Enum UnicodeEncoding Specifies the type of character encoding for a stream. Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public enum UnicodeEncoding : int Fields Name Description Utf8 The encoding is UTF-8."
  },
  "api/Windows.Storage.Streams.InputStreamOptions.html": {
    "href": "api/Windows.Storage.Streams.InputStreamOptions.html",
    "title": "Enum InputStreamOptions | nanoFramework Documentation",
    "keywords": "Enum InputStreamOptions Specifies the read options for an input stream. Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public enum InputStreamOptions : int Fields Name Description None No options are specified. Partial The asynchronous read operation completes when one or more bytes is available. ReadAhead The asynchronous read operation may optionally read ahead and prefetch additional bytes."
  },
  "api/Windows.Storage.Streams.DataReader.html": {
    "href": "api/Windows.Storage.Streams.DataReader.html",
    "title": "Class DataReader | nanoFramework Documentation",
    "keywords": "Class DataReader Inheritance System.Object DataReader Implements IDataReader Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public sealed class DataReader : IDisposable, IDataReader Constructors | Improve this Doc View Source DataReader(IInputStream) Creates and initializes a new instance of the data reader. Declaration public DataReader(IInputStream inputStream) Parameters Type Name Description IInputStream inputStream The input stream. Properties | Improve this Doc View Source ByteOrder Gets or sets the byte order of the data in the input stream. Declaration public ByteOrder ByteOrder { get; set; } Property Value Type Description ByteOrder One of the enumeration values. | Improve this Doc View Source InputStreamOptions Gets or sets the read options for the input stream. Declaration public InputStreamOptions InputStreamOptions { get; set; } Property Value Type Description InputStreamOptions One of the enumeration values. | Improve this Doc View Source UnconsumedBufferLength Gets the size of the buffer that has not been read. Declaration public uint UnconsumedBufferLength { get; } Property Value Type Description System.UInt32 The size of the buffer that has not been read, in bytes. | Improve this Doc View Source UnicodeEncoding Gets or sets the Unicode character encoding for the input stream. Declaration public UnicodeEncoding UnicodeEncoding { get; set; } Property Value Type Description UnicodeEncoding One of the enumeration values. Methods | Improve this Doc View Source Close() Closes the current stream and releases system resources. Declaration public void Close() Remarks DataReader takes ownership of the stream that is passed to its constructor. Calling this method also calls on the associated stream. After calling this method, calls to most other DataReader methods will fail. If you do not want the associated stream to be closed when the reader closes, call DataReader.DetachStream before calling this method. | Improve this Doc View Source DetachBuffer() Detaches a buffer that was previously attached to the reader. Declaration public IBuffer DetachBuffer() Returns Type Description IBuffer The detached buffer. | Improve this Doc View Source DetachStream() Detaches a stream that was previously attached to the reader. Declaration public IInputStream DetachStream() Returns Type Description IInputStream The detached stream. | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Improve this Doc View Source FromBuffer(IBuffer) Creates a new instance of the data reader with data from the specified buffer. Declaration public static DataReader FromBuffer(IBuffer buffer) Parameters Type Name Description IBuffer buffer The buffer. Returns Type Description DataReader The data reader. | Improve this Doc View Source Load(UInt32) Loads data from the input stream. Declaration public uint Load(UInt32 count) Parameters Type Name Description UInt32 count The count of bytes to load into the intermediate buffer. Returns Type Description System.UInt32 The operation. | Improve this Doc View Source ReadBoolean() Reads a Boolean value from the input stream. Declaration public bool ReadBoolean() Returns Type Description System.Boolean The value. | Improve this Doc View Source ReadBuffer(UInt32) Reads a buffer from the input stream. Declaration public IBuffer ReadBuffer(UInt32 length) Parameters Type Name Description UInt32 length The length of the buffer, in bytes. Returns Type Description IBuffer The buffer. | Improve this Doc View Source ReadByte() Reads a byte value from the input stream. Declaration public byte ReadByte() Returns Type Description System.Byte The value. | Improve this Doc View Source ReadBytes(Byte[]) Reads an array of byte values from the input stream. Declaration public void ReadBytes(Byte[] value) Parameters Type Name Description Byte [] value The array of values. | Improve this Doc View Source ReadDateTime() Reads a date and time value from the input stream. Declaration public DateTime ReadDateTime() Returns Type Description DateTime The value. | Improve this Doc View Source ReadDouble() Reads a floating-point value from the input stream. Declaration public double ReadDouble() Returns Type Description System.Double The value. | Improve this Doc View Source ReadGuid() Reads a GUID value from the input stream. Declaration public Guid ReadGuid() Returns Type Description Guid The value. | Improve this Doc View Source ReadInt16() Reads a 16-bit integer value from the input stream. Declaration public short ReadInt16() Returns Type Description System.Int16 The value. | Improve this Doc View Source ReadInt32() Reads a 32-bit integer value from the input stream. Declaration public int ReadInt32() Returns Type Description System.Int32 The value. | Improve this Doc View Source ReadInt64() Reads a 64-bit integer value from the input stream. Declaration public long ReadInt64() Returns Type Description System.Int64 The value. | Improve this Doc View Source ReadSingle() Reads a floating-point value from the input stream. Declaration public float ReadSingle() Returns Type Description System.Single The value. | Improve this Doc View Source ReadString(UInt32) Reads a string value from the input stream. Declaration public string ReadString(UInt32 codeUnitCount) Parameters Type Name Description UInt32 codeUnitCount The length of the string. Returns Type Description System.String The value. | Improve this Doc View Source ReadTimeSpan() Reads a time interval from the input stream. Declaration public TimeSpan ReadTimeSpan() Returns Type Description TimeSpan The value. | Improve this Doc View Source ReadUInt16() Reads a 16-bit unsigned integer from the input stream. Declaration public ushort ReadUInt16() Returns Type Description System.UInt16 The value. | Improve this Doc View Source ReadUInt32() Reads a 32-bit unsigned integer from the input stream. Declaration public uint ReadUInt32() Returns Type Description System.UInt32 The value. | Improve this Doc View Source ReadUInt64() Reads a 64-bit unsigned integer from the input stream. Declaration public ulong ReadUInt64() Returns Type Description System.UInt64 The value. Implements IDataReader"
  },
  "api/Windows.Storage.Streams.ByteOrder.html": {
    "href": "api/Windows.Storage.Streams.ByteOrder.html",
    "title": "Enum ByteOrder | nanoFramework Documentation",
    "keywords": "Enum ByteOrder Specifies the byte order of a stream. Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public enum ByteOrder : int Fields Name Description BigEndian The most significant byte (highest address) is stored first. LittleEndian The least significant byte (lowest address) is stored first."
  },
  "api/Windows.Storage.Streams.html": {
    "href": "api/Windows.Storage.Streams.html",
    "title": "Namespace Windows.Storage.Streams | nanoFramework Documentation",
    "keywords": "Namespace Windows.Storage.Streams Classes Buffer Provides a default implementation of the IBuffer interface and its related interfaces. DataReader DataWriter Writes data to an output stream. Interfaces IBuffer Represents a referenced array of bytes used by byte stream read and write interfaces. Buffer is the class implementation of this interface. IDataReader Provides read access to an input stream. IDataWriter Provides write access to an output stream. IInputStream IOutputStream Represents a sequential stream of bytes to be written. Enums ByteOrder Specifies the byte order of a stream. InputStreamOptions Specifies the read options for an input stream. UnicodeEncoding Specifies the type of character encoding for a stream."
  },
  "api/Windows.Storage.Streams.IOutputStream.html": {
    "href": "api/Windows.Storage.Streams.IOutputStream.html",
    "title": "Interface IOutputStream | nanoFramework Documentation",
    "keywords": "Interface IOutputStream Represents a sequential stream of bytes to be written. Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public interface IOutputStream Methods | Improve this Doc View Source Flush() Flushes data in a sequential stream. Declaration bool Flush() Returns Type Description System.Boolean The stream flush operation. Remarks The Flush method may produce latencies and does not always guarantee durable and coherent storage of data. It's generally recommended to avoid this method if possible. | Improve this Doc View Source Write(IBuffer) Writes data in a sequential stream. Declaration uint Write(IBuffer buffer) Parameters Type Name Description IBuffer buffer A buffer that contains the data to be written. Returns Type Description System.UInt32 The byte writer operation."
  },
  "api/Windows.Storage.Streams.IInputStream.html": {
    "href": "api/Windows.Storage.Streams.IInputStream.html",
    "title": "Interface IInputStream | nanoFramework Documentation",
    "keywords": "Interface IInputStream Namespace : Windows.Storage.Streams Assembly : Windows.Storage.Streams.dll Syntax public interface IInputStream Methods | Improve this Doc View Source Read(IBuffer, UInt32, InputStreamOptions) Reads data from the stream. Declaration IBuffer Read(IBuffer buffer, UInt32 count, InputStreamOptions options) Parameters Type Name Description IBuffer buffer A buffer that may be used to return the bytes that are read. The return value contains the buffer that holds the results. UInt32 count The number of bytes to read that is less than or equal to the Capacity value. InputStreamOptions options Specifies the type of the asynchronous read operation. Returns Type Description IBuffer The Buffer Remarks Don't assume that the input buffer contains the data. Depending on the implementation, the data that's read might be placed into the input buffer, or it might be returned in a different buffer. For the input buffer, you don't have to implement the IBuffer interface. Instead, you can create an instance of the Buffer class."
  }
}